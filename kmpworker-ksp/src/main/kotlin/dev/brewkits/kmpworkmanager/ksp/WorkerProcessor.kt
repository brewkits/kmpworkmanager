package dev.brewkits.kmpworkmanager.ksp

import com.google.devtools.ksp.processing.*
import com.google.devtools.ksp.symbol.*
import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ksp.toClassName
import com.squareup.kotlinpoet.ksp.writeTo

/**
 * KSP processor for @Worker annotation
 * Generates WorkerFactory implementation automatically
 *
 * v2.2.2+ Experimental feature
 */
class WorkerProcessor(
    private val codeGenerator: CodeGenerator,
    private val logger: KSPLogger
) : SymbolProcessor {

    override fun process(resolver: Resolver): List<KSAnnotated> {
        // Find all classes annotated with @Worker
        val workerSymbols = resolver
            .getSymbolsWithAnnotation("dev.brewkits.kmpworkmanager.annotations.Worker")
            .filterIsInstance<KSClassDeclaration>()

        if (!workerSymbols.iterator().hasNext()) {
            // No @Worker annotations found - skip generation
            return emptyList()
        }

        val workers = mutableListOf<WorkerInfo>()
        val androidWorkers = mutableListOf<WorkerInfo>()
        val iosWorkers = mutableListOf<WorkerInfo>()

        workerSymbols.forEach { classDecl ->
            val annotation = classDecl.annotations.first {
                it.shortName.asString() == "Worker"
            }

            // Get worker name from annotation or use class simple name
            val workerName = annotation.arguments
                .firstOrNull { it.name?.asString() == "name" }
                ?.value as? String
                ?: ""

            val finalName = workerName.ifEmpty { classDecl.simpleName.asString() }
            val className = classDecl.toClassName()

            val workerInfo = WorkerInfo(
                name = finalName,
                className = className,
                packageName = classDecl.packageName.asString()
            )

            workers.add(workerInfo)

            // Detect platform by checking superclass
            val superTypes = classDecl.superTypes.map { it.resolve().declaration.simpleName.asString() }

            when {
                superTypes.contains("AndroidWorker") -> androidWorkers.add(workerInfo)
                superTypes.contains("IosWorker") -> iosWorkers.add(workerInfo)
                else -> {
                    logger.warn("Worker ${classDecl.simpleName.asString()} doesn't extend AndroidWorker or IosWorker")
                }
            }
        }

        // Generate Android factory if there are Android workers
        if (androidWorkers.isNotEmpty()) {
            generateAndroidFactory(androidWorkers, resolver)
        }

        // Generate iOS factory if there are iOS workers
        if (iosWorkers.isNotEmpty()) {
            generateIosFactory(iosWorkers, resolver)
        }

        logger.info("Generated factories for ${workers.size} workers (${androidWorkers.size} Android, ${iosWorkers.size} iOS)")

        return emptyList()
    }

    private fun generateAndroidFactory(workers: List<WorkerInfo>, resolver: Resolver) {
        val packageName = "dev.brewkits.kmpworkmanager.generated"
        val className = "AndroidWorkerFactoryGenerated"

        val fileSpec = FileSpec.builder(packageName, className)
            .addFileComment(
                """
                AUTO-GENERATED by KSP WorkerProcessor
                Do not modify this file manually!

                To regenerate, rebuild your project.
                Generated from ${workers.size} @Worker annotated classes.
                """.trimIndent()
            )
            .addType(
                TypeSpec.classBuilder(className)
                    .addSuperinterface(ClassName("dev.brewkits.kmpworkmanager.background.domain", "AndroidWorkerFactory"))
                    .addFunction(
                        FunSpec.builder("createWorker")
                            .addModifiers(KModifier.OVERRIDE)
                            .addParameter("workerClassName", String::class)
                            .returns(ClassName("dev.brewkits.kmpworkmanager.background.domain", "AndroidWorker").copy(nullable = true))
                            .beginControlFlow("return when (workerClassName)")
                            .apply {
                                workers.forEach { worker ->
                                    addStatement("%S -> %T()", worker.name, worker.className)
                                }
                            }
                            .addStatement("else -> null")
                            .endControlFlow()
                            .build()
                    )
                    .build()
            )
            .build()

        // Write to output
        fileSpec.writeTo(codeGenerator, Dependencies(false))

        logger.info("Generated Android factory: $packageName.$className")
    }

    private fun generateIosFactory(workers: List<WorkerInfo>, resolver: Resolver) {
        val packageName = "dev.brewkits.kmpworkmanager.generated"
        val className = "IosWorkerFactoryGenerated"

        val fileSpec = FileSpec.builder(packageName, className)
            .addFileComment(
                """
                AUTO-GENERATED by KSP WorkerProcessor
                Do not modify this file manually!

                To regenerate, rebuild your project.
                Generated from ${workers.size} @Worker annotated classes.
                """.trimIndent()
            )
            .addType(
                TypeSpec.classBuilder(className)
                    .addSuperinterface(ClassName("dev.brewkits.kmpworkmanager.background.data", "IosWorkerFactory"))
                    .addFunction(
                        FunSpec.builder("createWorker")
                            .addModifiers(KModifier.OVERRIDE)
                            .addParameter("workerClassName", String::class)
                            .returns(ClassName("dev.brewkits.kmpworkmanager.background.data", "IosWorker").copy(nullable = true))
                            .beginControlFlow("return when (workerClassName)")
                            .apply {
                                workers.forEach { worker ->
                                    addStatement("%S -> %T()", worker.name, worker.className)
                                }
                            }
                            .addStatement("else -> null")
                            .endControlFlow()
                            .build()
                    )
                    .build()
            )
            .build()

        // Write to output
        fileSpec.writeTo(codeGenerator, Dependencies(false))

        logger.info("Generated iOS factory: $packageName.$className")
    }
}

/**
 * Worker information extracted from @Worker annotation
 */
private data class WorkerInfo(
    val name: String,
    val className: ClassName,
    val packageName: String
)
