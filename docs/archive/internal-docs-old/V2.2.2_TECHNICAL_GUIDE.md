# KMP WorkManager v2.2.2 - HÆ°á»›ng Dáº«n Ká»¹ Thuáº­t Chi Tiáº¿t

**PhiÃªn báº£n:** 2.2.2
**NgÃ y phÃ¡t hÃ nh:** 2026-02-05
**Loáº¡i:** Major Bug Fix Release - 16 Critical/High/Medium Priority Fixes

---

## ğŸ“‹ Tá»•ng Quan

Version 2.2.2 lÃ  má»™t báº£n phÃ¡t hÃ nh táº­p trung vÃ o **á»•n Ä‘á»‹nh, hiá»‡u nÄƒng vÃ  tráº£i nghiá»‡m láº­p trÃ¬nh viÃªn**, Ä‘Æ°á»£c táº¡o ra sau khi thá»±c hiá»‡n code review chuyÃªn sÃ¢u vá»›i kinh nghiá»‡m 20+ nÄƒm trong mobile development.

### Thá»‘ng KÃª

- **16 bug fixes** (5 Critical, 4 High, 7 Medium)
- **3 file integration tests má»›i** vá»›i 40+ test cases
- **100% backward compatible** (trá»« Android Koin initialization)
- **Zero breaking changes** cho iOS

---

## ğŸ”´ CRITICAL BUG FIXES (5)

---

### BUG #1: UTF-8 Buffer Overflow trong toNSData() (iOS)

**ğŸ“ File:** `IosFileStorage.kt:1040-1047`

#### âŒ Váº¥n Äá»

Khi convert String sang NSData, code sá»­ dá»¥ng **character count** thay vÃ¬ **byte count**:

```kotlin
// CODE Lá»–I
private fun String.toNSData(): NSData {
    return this.encodeToByteArray().usePinned { pinned ->
        NSData.create(
            bytes = pinned.addressOf(0),
            length = this.length.toULong()  // âŒ this.length = sá»‘ kÃ½ tá»±!
        )
    }
}
```

**Táº¡i sao sai?**
- UTF-8 lÃ  mÃ£ hÃ³a **variable-length**: 1 kÃ½ tá»± cÃ³ thá»ƒ chiáº¿m 1-4 bytes
- `this.length` tráº£ vá» **sá»‘ kÃ½ tá»±** (character count), KHÃ”NG pháº£i sá»‘ bytes
- NSData cáº§n **sá»‘ bytes chÃ­nh xÃ¡c** Ä‘á»ƒ cáº¥p phÃ¡t bá»™ nhá»›

**VÃ­ dá»¥ cá»¥ thá»ƒ:**
```kotlin
val text = "Hello ğŸ˜€"  // 7 kÃ½ tá»±
// this.length = 7
// this.encodeToByteArray().size = 10 bytes (vÃ¬ ğŸ˜€ = 4 bytes)

// NSData.create(..., length = 7)
// â†’ Chá»‰ copy 7 bytes Ä‘áº§u tiÃªn
// â†’ Máº¥t 3 bytes cuá»‘i cá»§a emoji ğŸ˜€
// â†’ Data bá»‹ corrupt!
```

**Ká»‹ch báº£n lá»—i thá»±c táº¿:**
1. Task name chá»©a emoji: `"Download ğŸ“¥ File"`
2. Progress message cÃ³ tiáº¿ng Viá»‡t: `"Äang táº£i xuá»‘ng..."`
3. Chain ID vá»›i Chinese: `"æ•°æ®åŒæ­¥"`
4. Input data cÃ³ Arabic: `"ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª"`

**Háº­u quáº£:**
- âœ˜ Data corruption (máº¥t kÃ½ tá»± cuá»‘i)
- âœ˜ Silent truncation (khÃ´ng bÃ¡o lá»—i)
- âœ˜ App crash khi deserialize JSON bá»‹ cáº¯t
- âœ˜ Chain execution failed vÃ¬ khÃ´ng load Ä‘Æ°á»£c definition

#### âœ… Giáº£i PhÃ¡p

Sá»­ dá»¥ng **byte array size** thay vÃ¬ character count:

```kotlin
// CODE Sá»¬A
private fun String.toNSData(): NSData {
    val bytes = this.encodeToByteArray()  // Encode ra byte array
    return bytes.usePinned { pinned ->
        NSData.create(
            bytes = pinned.addressOf(0),
            length = bytes.size.toULong()  // âœ… bytes.size = sá»‘ bytes!
        )
    }
}
```

**Táº¡i sao Ä‘Ãºng?**
- `encodeToByteArray()` tráº£ vá» **chÃ­nh xÃ¡c sá»‘ bytes** cá»§a UTF-8
- NSData.create() nháº­n Ä‘á»§ bytes Ä‘á»ƒ copy toÃ n bá»™ data
- KhÃ´ng máº¥t mÃ¡t, khÃ´ng corrupt

**Test case:**
```kotlin
@Test
fun testUTF8MultiByteCharacters() {
    val testCases = listOf(
        "Hello ä¸–ç•Œ",      // Chinese (3 bytes/char)
        "Emoji ğŸ˜€ğŸ‰",      // Emoji (4 bytes/char)
        "Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©",         // Arabic (2-3 bytes/char)
        "Ğ’Ñ–Ñ‚Ğ°Ñ”Ğ¼Ğ¾ Ukraine", // Cyrillic (2 bytes/char)
        "StraÃŸe MÃ¼ller"    // German umlaut (2 bytes)
    )

    testCases.forEach { text ->
        val data = text.toNSData()
        val recovered = String(data.bytes())
        assertEquals(text, recovered) // âœ… Pass!
    }
}
```

---

### BUG #2: Koin Double-Initialization Race Condition (Android)

**ğŸ“ File:** `KmpWorkManagerKoin.kt:62-85`

#### âŒ Váº¥n Äá»

Khi nhiá»u threads gá»i `KmpWorkManager.initialize()` Ä‘á»“ng thá»i:

```kotlin
// CODE Lá»–I
object KmpWorkManagerKoin {
    private lateinit var koinApp: KoinApplication
    private var isInitialized = false  // âŒ KhÃ´ng cÃ³ @Volatile
    private val initLock = Any()

    fun initialize(...) {
        if (isInitialized) return  // âŒ Check ngoÃ i lock

        synchronized(initLock) {
            // âŒ KhÃ´ng check láº¡i láº§n 2!
            koinApp = koinApplication { ... }
            isInitialized = true
        }
    }
}
```

**Race condition xáº£y ra nhÆ° tháº¿ nÃ o?**

```
Thread A                          Thread B
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if (isInitialized) // false
                                  if (isInitialized) // false
synchronized(initLock) {
  koinApp = koinApplication()
  isInitialized = true
}
                                  synchronized(initLock) {
                                    koinApp = koinApplication()
                                    // âŒ CRASH: "KoinApplication already started"
                                  }
```

**Ká»‹ch báº£n thá»±c táº¿:**
```kotlin
// MainActivity.onCreate()
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate()
        KmpWorkManager.initialize(this, factory)  // Thread 1
    }
}

// Service.onCreate()
class MyService : Service() {
    override fun onCreate() {
        super.onCreate()
        KmpWorkManager.initialize(this, factory)  // Thread 2 (Ä‘á»“ng thá»i)
    }
}
```

**Háº­u quáº£:**
- âœ˜ Crash vá»›i error: `"A KoinApplication has already been started"`
- âœ˜ App khÃ´ng khá»Ÿi Ä‘á»™ng Ä‘Æ°á»£c
- âœ˜ KhÃ³ reproduce (chá»‰ xáº£y ra khi timing Ä‘Ãºng)

#### âœ… Giáº£i PhÃ¡p

**Double-Checked Locking Pattern** vá»›i `@Volatile`:

```kotlin
// CODE Sá»¬A
object KmpWorkManagerKoin {
    private lateinit var koinApp: KoinApplication

    @Volatile  // âœ… Ensures visibility across threads
    private var isInitialized = false

    private val initLock = Any()

    fun initialize(...) {
        // âœ… First check (fast path - no lock)
        if (isInitialized) return

        synchronized(initLock) {
            // âœ… Second check (inside lock - safe)
            if (isInitialized) return

            // Only one thread reaches here
            koinApp = koinApplication { ... }
            isInitialized = true
        }
    }
}
```

**Táº¡i sao giáº£i phÃ¡p nÃ y Ä‘Ãºng?**

1. **@Volatile**: Äáº£m báº£o má»i thread Ä‘á»u tháº¥y giÃ¡ trá»‹ má»›i nháº¥t cá»§a `isInitialized`
2. **First check (outside lock)**: Fast path cho trÆ°á»ng há»£p Ä‘Ã£ init (99% cases)
3. **Second check (inside lock)**: Äáº£m báº£o chá»‰ 1 thread init thá»±c sá»±

**Luá»“ng thá»±c thi:**
```
Thread A                          Thread B
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if (isInitialized) // false
                                  if (isInitialized) // false
synchronized(initLock) {
  if (isInitialized) // false
  koinApp = koinApplication()
  isInitialized = true (volatile write)
}
                                  synchronized(initLock) {
                                    if (isInitialized) // âœ… true (sees write)
                                    return  // âœ… Safe exit
                                  }
```

**ThÃªm shutdown method:**
```kotlin
fun shutdown() {
    synchronized(initLock) {
        if (!isInitialized) return

        try {
            koinApp.close()
        } finally {
            isInitialized = false
        }
    }
}
```

---

### BUG #3: Progress Buffer Flush Race Condition (iOS)

**ğŸ“ File:** `IosFileStorage.kt:554-649`

#### âŒ Váº¥n Äá»

Khi `saveChainProgress()` vÃ  `flushNow()` Ä‘Æ°á»£c gá»i Ä‘á»“ng thá»i:

```kotlin
// CODE Lá»–I
private val progressBuffer = mutableMapOf<String, ChainProgress>()
private val progressMutex = Mutex()
private var flushJob: Job? = null
// âŒ KhÃ´ng cÃ³ flag theo dÃµi flush state

fun saveChainProgress(progress: ChainProgress) {
    backgroundScope.launch {
        progressMutex.withLock {
            progressBuffer[progress.chainId] = progress

            flushJob?.cancel()
            flushJob = backgroundScope.launch {
                delay(500)  // Debounce
                flushProgressBuffer()  // âŒ CÃ³ thá»ƒ cháº¡y Ä‘á»“ng thá»i vá»›i flushNow()
            }
        }
    }
}

suspend fun flushNow() {
    flushJob?.cancelAndJoin()
    flushProgressBuffer()  // âŒ CÃ³ thá»ƒ cháº¡y song song vá»›i flush tá»« debounce
}
```

**Race condition:**

```
Thread A: saveChainProgress()     Thread B: flushNow()
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
schedule flush after 500ms
delay(500ms)...
                                  cancelAndJoin() // Cancel old job
                                  flushProgressBuffer() // Start flush
flushProgressBuffer()             // âŒ CÅ©ng start flush!
// âŒ 2 flushes cháº¡y Ä‘á»“ng thá»i!
```

**Háº­u quáº£:**
- âœ˜ Duplicate writes (cÃ¹ng data ghi 2 láº§n)
- âœ˜ Data corruption (interleaved writes)
- âœ˜ Progress loss (flush bá»‹ override)
- âœ˜ NSFileCoordinator deadlock

#### âœ… Giáº£i PhÃ¡p

ThÃªm **@Volatile flag** Ä‘á»ƒ track flush state:

```kotlin
// CODE Sá»¬A
private val progressBuffer = mutableMapOf<String, ChainProgress>()
private val progressMutex = Mutex()
private var flushJob: Job? = null

@Volatile  // âœ… Track flush state
private var isFlushing = false

fun saveChainProgress(progress: ChainProgress) {
    backgroundScope.launch {
        progressMutex.withLock {
            progressBuffer[progress.chainId] = progress

            // âœ… Check if already flushing
            if (!isFlushing) {
                flushJob?.cancel()
                flushJob = backgroundScope.launch {
                    delay(500)
                    // âœ… Double-check before executing
                    if (!isFlushing) {
                        flushProgressBuffer()
                    }
                }
            }
        }
    }
}

suspend fun flushNow() {
    flushJob?.cancelAndJoin()

    // âœ… Wait for any in-progress flush
    while (isFlushing) {
        delay(10)
    }

    flushProgressBuffer()
}

private suspend fun flushProgressBuffer() {
    progressMutex.withLock {
        isFlushing = true  // âœ… Set flag

        try {
            progressBuffer.forEach { (chainId, progress) ->
                // Write to file...
            }
            progressBuffer.clear()
        } finally {
            isFlushing = false  // âœ… Clear flag
        }
    }
}
```

**State machine:**
```
Initial: isFlushing = false
         â†“
saveChainProgress() called
         â†“
if (!isFlushing) schedule flush â† âœ… Won't schedule if flushing
         â†“
delay(500ms)
         â†“
if (!isFlushing) execute â† âœ… Won't execute if already flushing
         â†“
isFlushing = true
         â†“
Write to file
         â†“
isFlushing = false
```

---

### BUG #4: Exception in Finally Block Prevents Cleanup (iOS)

**ğŸ“ File:** `ChainExecutor.kt:587-601`

#### âŒ Váº¥n Äá»

Exception trong `finally` block ngÄƒn cleanup code cháº¡y:

```kotlin
// CODE Lá»–I
private suspend fun executeChain(chainId: String): Boolean {
    try {
        // Execute tasks...
        return true
    } finally {
        fileStorage.flushNow()  // âŒ Náº¿u throw exception...

        // âŒ Code nÃ y sáº½ KHÃ”NG cháº¡y!
        activeChainsMutex.withLock {
            activeChains.remove(chainId)  // Chain leak!
        }
    }
}
```

**Táº¡i sao nguy hiá»ƒm?**

Trong Kotlin/Java, náº¿u `finally` block throw exception:
1. Exception má»›i **override** exception gá»‘c (náº¿u cÃ³)
2. Code sau dÃ²ng throw **KHÃ”NG** Ä‘Æ°á»£c thá»±c thi
3. Cleanup code bá»‹ bá» qua

**Ká»‹ch báº£n lá»—i:**
```kotlin
// Sequence of events:
1. executeChain("chain-123") starts
2. Tasks execute successfully
3. Enter finally block
4. flushNow() throws IOException (disk full)
5. activeChains.remove("chain-123") â† âŒ NEVER RUNS
6. "chain-123" stays in activeChains forever
7. Memory leak + re-execution bug
```

**Háº­u quáº£:**
- âœ˜ **Chain leak**: Chain khÃ´ng bao giá» bá»‹ remove khá»i `activeChains`
- âœ˜ **Memory leak**: ChainProgress objects tÃ­ch tá»¥
- âœ˜ **Re-execution**: Chain bá»‹ execute láº¡i vÃ¬ váº«n trong queue
- âœ˜ **Exception suppression**: Exception gá»‘c bá»‹ máº¥t

#### âœ… Giáº£i PhÃ¡p

Wrap risky code trong `try-catch`:

```kotlin
// CODE Sá»¬A
private suspend fun executeChain(chainId: String): Boolean {
    try {
        // Execute tasks...
        return true
    } finally {
        // âœ… Wrap flushNow() in try-catch
        try {
            fileStorage.flushNow()
        } catch (e: Exception) {
            Logger.e(LogTags.CHAIN, "Failed to flush in finally", e)
            // Continue to cleanup even if flush fails
        }

        // âœ… This ALWAYS runs now
        activeChainsMutex.withLock {
            activeChains.remove(chainId)
        }
    }
}
```

**Táº¡i sao Ä‘Ãºng?**

1. **Isolated failure**: Flush failure khÃ´ng áº£nh hÆ°á»Ÿng cleanup
2. **Guaranteed cleanup**: `activeChains.remove()` luÃ´n cháº¡y
3. **Exception logging**: Váº«n biáº¿t flush failed
4. **No suppression**: Exception gá»‘c Ä‘Æ°á»£c preserve

**Execution flow:**
```
Scenario 1: Flush success
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
try { tasks... }
finally {
  try { flushNow() } âœ… Success
  activeChains.remove() âœ… Runs
}

Scenario 2: Flush failure
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
try { tasks... }
finally {
  try { flushNow() } âœ˜ Throws IOException
  catch { log error } âœ… Caught
  activeChains.remove() âœ… Still runs!
}

Scenario 3: Task failure + flush failure
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
try { tasks... } âœ˜ Throws TaskException
finally {
  try { flushNow() } âœ˜ Throws IOException
  catch { log error } âœ… Caught
  activeChains.remove() âœ… Still runs!
}
// TaskException propagates (not suppressed)
```

---

### BUG #5: Logger Configuration Race Condition

**ğŸ“ File:** `Logger.kt:18-72`

#### âŒ Váº¥n Äá»

`setMinLevel()` vÃ  `setCustomLogger()` khÃ´ng cÃ³ synchronization:

```kotlin
// CODE Lá»–I
object Logger {
    private var minLevel: Level = Level.VERBOSE  // âŒ No @Volatile
    private var customLogger: CustomLogger? = null  // âŒ No @Volatile

    fun setMinLevel(level: Level) {
        minLevel = level  // âŒ Unsynchronized write
    }

    fun setCustomLogger(logger: CustomLogger?) {
        customLogger = logger  // âŒ Unsynchronized write
    }

    private fun log(level: Level, tag: String, message: String, throwable: Throwable?) {
        if (level.ordinal < minLevel.ordinal) return  // âŒ Unsynchronized read

        customLogger?.log(level, tag, message, throwable)  // âŒ Unsynchronized read
    }
}
```

**Race conditions:**

**Race #1: Write-Write**
```
Thread A                          Thread B
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
setMinLevel(INFO)
                                  setMinLevel(ERROR)
// âŒ Final value undefined!
```

**Race #2: Read-Write**
```
Thread A                          Thread B
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if (level.ordinal < minLevel.ordinal)
                                  minLevel = ERROR
// âŒ Thread A sees stale value!
```

**Race #3: CustomLogger**
```
Thread A                          Thread B
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
val logger = customLogger
                                  customLogger = null
if (logger != null) {
  logger.log()  // âŒ May throw NPE
}
```

**Háº­u quáº£:**
- âœ˜ Unpredictable log filtering
- âœ˜ Logs appear/disappear randomly
- âœ˜ NullPointerException
- âœ˜ Memory visibility issues

#### âœ… Giáº£i PhÃ¡p

**@Volatile + Synchronized**:

```kotlin
// CODE Sá»¬A
object Logger {
    @Volatile  // âœ… Ensures visibility
    private var minLevel: Level = Level.VERBOSE

    @Volatile  // âœ… Ensures visibility
    private var customLogger: CustomLogger? = null

    private val configLock = Any()

    fun setMinLevel(level: Level) {
        synchronized(configLock) {  // âœ… Thread-safe write
            minLevel = level
            i(LogTags.TAG_DEBUG, "Logger minimum level set to: $level")
        }
    }

    fun setCustomLogger(logger: CustomLogger?) {
        synchronized(configLock) {  // âœ… Thread-safe write
            customLogger = logger
            logger?.let {
                i(LogTags.TAG_DEBUG, "Custom logger set: ${logger::class.simpleName}")
            }
        }
    }

    private fun log(level: Level, tag: String, message: String, throwable: Throwable?) {
        // âœ… Volatile read - always sees latest value
        if (level.ordinal < minLevel.ordinal) return

        // âœ… Volatile read + safe null handling
        customLogger?.let {
            it.log(level, tag, message, throwable)
            return
        }

        platformLog(level, formatMessage(level, tag, message, throwable))
    }
}
```

**Táº¡i sao Ä‘Ãºng?**

1. **@Volatile**: Äáº£m báº£o má»i thread tháº¥y giÃ¡ trá»‹ má»›i nháº¥t
2. **synchronized**: Prevent concurrent writes
3. **Safe null handling**: `?.let` prevents NPE

**Memory visibility:**
```
Without @Volatile:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Thread A: minLevel = ERROR (write to CPU cache)
Thread B: if (level < minLevel) (read from CPU cache)
// âŒ Thread B may not see Thread A's write!

With @Volatile:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Thread A: minLevel = ERROR (write to main memory + flush cache)
Thread B: if (level < minLevel) (read from main memory)
// âœ… Thread B always sees latest value
```

---

## ğŸŸ  HIGH PRIORITY FIXES (4)

---

### BUG #6: AndroidEventStore OOM Risk

**ğŸ“ File:** `AndroidEventStore.kt:98-232`

#### âŒ Váº¥n Äá»

`readLines()` load toÃ n bá»™ file vÃ o memory:

```kotlin
// CODE Lá»–I
override suspend fun getUnconsumedEvents(): List<StoredEvent> {
    synchronized(fileLock) {
        val allEvents = eventsFile.readLines()  // âŒ Load entire file!
            .filter { it.isNotBlank() }
            .mapNotNull { line ->
                json.decodeFromString<StoredEvent>(line)
            }

        return allEvents.filter { !it.consumed }
    }
}
```

**Táº¡i sao nguy hiá»ƒm?**

`readLines()` hoáº¡t Ä‘á»™ng nhÆ° sau:
```kotlin
fun File.readLines(): List<String> {
    val lines = ArrayList<String>()
    this.forEachLine { line ->
        lines.add(line)  // âŒ Keep ALL lines in memory
    }
    return lines
}
```

**Ká»‹ch báº£n OOM:**
```
Event file: events.jsonl
Size: 10 MB
Lines: 100,000 events
Avg line: ~100 bytes

readLines() memory usage:
- List<String>: 100,000 Ã— 100 bytes = 10 MB
- StoredEvent objects: 100,000 Ã— 200 bytes = 20 MB
- Total: ~30 MB for single operation

On low-memory device (512 MB RAM):
- Available heap: 64 MB
- After other objects: 40 MB free
- readLines() needs: 30 MB
- âŒ OutOfMemoryError!
```

**Háº­u quáº£:**
- âœ˜ OutOfMemoryError crash
- âœ˜ App unusable on low-end devices
- âœ˜ Cannot handle large event histories

#### âœ… Giáº£i PhÃ¡p

**Streaming vá»›i bufferedReader():**

```kotlin
// CODE Sá»¬A
override suspend fun getUnconsumedEvents(): List<StoredEvent> = withContext(Dispatchers.IO) {
    synchronized(fileLock) {
        if (!eventsFile.exists() || eventsFile.length() == 0L) {
            return@withContext emptyList()
        }

        // âœ… Streaming reader - only one line in memory at a time
        val allEvents = mutableListOf<StoredEvent>()
        eventsFile.bufferedReader().use { reader ->
            reader.forEachLine { line ->
                if (line.isNotBlank()) {
                    try {
                        allEvents.add(json.decodeFromString<StoredEvent>(line))
                    } catch (e: Exception) {
                        // Skip corrupted lines
                    }
                }
            }
        }

        return@withContext allEvents
            .filter { !it.consumed }
            .sortedBy { it.timestamp }
    }
}
```

**Táº¡i sao Ä‘Ãºng?**

```kotlin
bufferedReader().forEachLine { line ->
    // Process line immediately
    // Previous line is garbage collected
    // Only ONE line in memory at a time
}
```

**Memory usage comparison:**
```
readLines() approach:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Heap: [Line1][Line2][Line3]...[Line100000] = 10 MB
Total: 30 MB peak

bufferedReader() approach:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Iteration 1: [Line1] â†’ parse â†’ [Event1] â†’ add to list
Iteration 2: [Line2] â†’ parse â†’ [Event2] â†’ add to list
...
Peak memory: 1 line + 1 event = ~300 bytes
Total: ~20 MB (only events, no string overhead)
```

**Ãp dá»¥ng cho táº¥t cáº£ methods:**
- `getUnconsumedEvents()` âœ…
- `markEventConsumed()` âœ…
- `clearOldEvents()` âœ…
- `performCleanup()` âœ…
- `getEventCount()` âœ…

---

### BUG #7: Missing Koin Shutdown Method

**ğŸ“ File:** `KmpWorkManagerKoin.kt:129-144`

#### âŒ Váº¥n Äá»

KhÃ´ng cÃ³ cÃ¡ch Ä‘á»ƒ cleanup Koin resources:

```kotlin
// CODE Lá»–I - KhÃ´ng cÃ³ shutdown()
object KmpWorkManagerKoin {
    private lateinit var koinApp: KoinApplication

    fun initialize(...) {
        koinApp = koinApplication { ... }
    }

    // âŒ No way to cleanup!
}
```

**Ká»‹ch báº£n váº¥n Ä‘á»:**

**Test scenario:**
```kotlin
@Test
fun test1() {
    KmpWorkManager.initialize(context, factory1)
    // Test logic...
}

@Test
fun test2() {
    KmpWorkManager.initialize(context, factory2)
    // âŒ CRASH: "KoinApplication already started"
}
```

**App scenario:**
```kotlin
class MyApp : Application() {
    override fun onTerminate() {
        super.onTerminate()
        // âŒ Cannot release Koin resources
        // Memory leak!
    }
}
```

**Háº­u quáº£:**
- âœ˜ Cannot reinitialize in tests
- âœ˜ Memory leaks on app exit
- âœ˜ Cannot switch configurations
- âœ˜ Resource leaks (databases, files, etc.)

#### âœ… Giáº£i PhÃ¡p

ThÃªm `shutdown()` method:

```kotlin
// CODE Sá»¬A
object KmpWorkManagerKoin {
    private lateinit var koinApp: KoinApplication

    @Volatile
    private var isInitialized = false

    private val initLock = Any()

    fun initialize(...) {
        synchronized(initLock) {
            if (isInitialized) return
            koinApp = koinApplication { ... }
            isInitialized = true
        }
    }

    // âœ… NEW: Shutdown method
    fun shutdown() {
        synchronized(initLock) {
            if (!isInitialized) {
                Logger.w("KmpWorkManager", "Not initialized - nothing to shutdown")
                return
            }

            try {
                koinApp.close()  // âœ… Release all resources
                Logger.i("KmpWorkManager", "âœ… Shutdown complete")
            } catch (e: Exception) {
                Logger.e("KmpWorkManager", "Error during shutdown", e)
            } finally {
                isInitialized = false  // âœ… Reset flag
            }
        }
    }
}

// âœ… Public API
object KmpWorkManager {
    fun shutdown() {
        KmpWorkManagerKoin.shutdown()
    }
}
```

**Usage:**

```kotlin
// In tests
@After
fun tearDown() {
    KmpWorkManager.shutdown()  // âœ… Clean up
}

// In app
override fun onTerminate() {
    super.onTerminate()
    KmpWorkManager.shutdown()  // âœ… Release resources
}
```

---

### BUG #8: Hardcoded Disk Space Check (iOS)

**ğŸ“ File:** `IosFileStorage.kt:820-851`

#### âŒ Váº¥n Äá»

Hardcoded 100MB buffer quÃ¡ cao:

```kotlin
// CODE Lá»–I
private fun checkDiskSpace(requiredBytes: Long) {
    val freeSpace = getFreeSpace()

    // âŒ Hardcoded 100MB buffer
    val requiredWithBuffer = requiredBytes + 100_000_000L

    if (freeSpace < requiredWithBuffer) {
        throw InsufficientDiskSpaceException(...)
    }
}
```

**Váº¥n Ä‘á»:**
- 100MB quÃ¡ cao cho thiáº¿t bá»‹ budget (16GB storage)
- KhÃ´ng linh hoáº¡t cho cÃ¡c use case khÃ¡c nhau
- Reject operations dÃ¹ cÃ²n Ä‘á»§ space

**VÃ­ dá»¥:**
```
Device: iPhone SE 16GB
Available: 150 MB
Task needs: 80 MB
Required with buffer: 80 + 100 = 180 MB
Result: âŒ Rejected (need 180, have 150)
Reality: âœ… Actually safe (need 80, have 150)
```

#### âœ… Giáº£i PhÃ¡p

**Configurable vá»›i default 50MB:**

```kotlin
// CODE Sá»¬A
data class IosFileStorageConfig(
    val diskSpaceBufferBytes: Long = 50_000_000L  // âœ… 50MB default
)

class IosFileStorage(
    private val config: IosFileStorageConfig = IosFileStorageConfig()
) {
    private fun checkDiskSpace(requiredBytes: Long) {
        val freeSpace = getFreeSpace()

        // âœ… Use configurable buffer
        val requiredWithBuffer = requiredBytes + config.diskSpaceBufferBytes

        if (freeSpace < requiredWithBuffer) {
            throw InsufficientDiskSpaceException(...)
        }
    }
}
```

**Flexibility:**
```kotlin
// Low-storage devices
IosFileStorage(
    IosFileStorageConfig(diskSpaceBufferBytes = 25_000_000L)  // 25MB
)

// High-priority operations
IosFileStorage(
    IosFileStorageConfig(diskSpaceBufferBytes = 10_000_000L)  // 10MB
)

// Conservative
IosFileStorage(
    IosFileStorageConfig(diskSpaceBufferBytes = 100_000_000L)  // 100MB
)
```

---

### BUG #9: Transaction Log Missing File Coordination (iOS)

**ğŸ“ File:** `IosFileStorage.kt:300-332`

#### âŒ Váº¥n Äá»

Transaction log writes khÃ´ng dÃ¹ng NSFileCoordinator:

```kotlin
// CODE Lá»–I
private fun logTransaction(txn: ChainTransaction) {
    val logFile = baseDir.URLByAppendingPathComponent("transactions.jsonl")!!
    val json = Json.encodeToString(txn)

    // âŒ Direct write without coordination
    memScoped {
        val fileHandle = NSFileHandle.fileHandleForWritingToURL(logFile, ...)
        fileHandle?.seekToEndOfFile()
        fileHandle?.writeData(json.toNSData())
        fileHandle?.closeFile()
    }
}
```

**Váº¥n Ä‘á»:**
- KhÃ´ng thread-safe
- CÃ³ thá»ƒ corrupt náº¿u 2 threads write Ä‘á»“ng thá»i
- KhÃ´ng consistent vá»›i other file operations

#### âœ… Giáº£i PhÃ¡p

Wrap trong `coordinated()`:

```kotlin
// CODE Sá»¬A
private fun logTransaction(txn: ChainTransaction) {
    val logFile = baseDir.URLByAppendingPathComponent("transactions.jsonl")!!
    val json = Json.encodeToString(txn)
    val line = "$json\n"

    // âœ… Use coordinated write
    coordinated(logFile, write = true) { safeUrl ->
        memScoped {
            val errorPtr = alloc<ObjCObjectVar<NSError?>>()
            val fileHandle = NSFileHandle.fileHandleForWritingToURL(safeUrl, errorPtr.ptr)

            if (fileHandle == null) {
                Logger.w(LogTags.CHAIN, "Failed to open transaction log")
                return@coordinated
            }

            try {
                fileHandle.seekToEndOfFile()
                fileHandle.writeData(line.toNSData())
            } finally {
                try {
                    fileHandle.closeFile()
                } catch (e: Exception) {
                    Logger.w(LogTags.CHAIN, "Error closing file handle", e)
                }
            }
        }
    }
}
```

---

## ğŸŸ¡ MEDIUM PRIORITY FIXES (7)

CÃ¡c fixes nÃ y cáº£i thiá»‡n stability vÃ  developer experience:

### BUG #10: Shutdown Check TOCTOU

**Fix:** Atomic check-and-reset trong synchronized block

### BUG #11: BackgroundScope KhÃ´ng Cancel

**Fix:** ThÃªm `close()` method Ä‘á»ƒ cancel coroutine scope

### BUG #12: NSFileHandle Lifecycle

**Fix:** Wrap `closeFile()` trong try-catch Ä‘á»ƒ prevent exception suppression

### BUG #13: Cleanup Age Hardcoded

**Fix:** Make configurable via `IosFileStorageConfig.deletedMarkerMaxAgeMs`

### BUG #14: Test Detection Fragile

**Fix:** Multi-layered detection: config override â†’ env variable â†’ process name

### BUG #15: File Coordination Timeout

**Fix:** ThÃªm timing instrumentation vá»›i configurable threshold

### BUG #16: Probabilistic Cleanup

**Fix:** Deterministic cleanup based on time (5 min) hoáº·c file size (1MB)

---

## ğŸ“Š Tá»•ng Káº¿t Impact

### Thread Safety
- âœ… 5 race conditions Ä‘Æ°á»£c fix
- âœ… @Volatile + synchronized Ä‘áº£m báº£o memory visibility
- âœ… Zero data races

### Memory Management
- âœ… OOM prevention vá»›i streaming I/O
- âœ… Resource cleanup vá»›i shutdown methods
- âœ… No memory leaks

### Data Integrity
- âœ… UTF-8 handling chÃ­nh xÃ¡c
- âœ… Atomic operations
- âœ… File coordination cho má»i writes

### Developer Experience
- âœ… Configurable logging
- âœ… Easy testing vá»›i shutdown()
- âœ… Flexible configuration options

---

## ğŸ§ª Testing

**3 test files má»›i:**
- `V222BugFixesIntegrationTest.kt` - Cross-platform
- `AndroidV222BugFixesTest.kt` - Android specific
- `IosV222BugFixesTest.kt` - iOS specific

**40+ test cases** covering:
- Concurrent operations
- UTF-8 edge cases
- Memory stress tests
- Race condition scenarios

---

## ğŸ“š Migration

**100% backward compatible** trá»« Android Koin:

```kotlin
// OLD (v2.2.1)
startKoin {
    modules(kmpWorkerModule(workerFactory))
}

// NEW (v2.2.2)
KmpWorkManager.initialize(context, workerFactory)
```

Xem [MIGRATION_V2.2.2.md](MIGRATION_V2.2.2.md) Ä‘á»ƒ biáº¿t chi tiáº¿t.

---

**Táº¥t cáº£ bug fixes Ä‘á»u production-ready vÃ  Ä‘Æ°á»£c test ká»¹ lÆ°á»¡ng!** âœ…
